local format = string.format

local generator = {
  outputlang = "lua",
  default_filename = "jitlog/reader_def.lua",
}

generator.templates = {
  comment_line = "-- %s",
  namelist = [[
local {{name}} = {
{{list:  "%s",\\n}}}

]],

  enum = [[
local {{name}} = make_enum{
{{list}}}
lib.{{name}} = {{name}}

]],
  enumline = '"%s",\n',
  msgsizes = [[local msgsizes = {
{{list}} };
lib.msgsizes = msgsizes

]],

  struct = [[
typedef struct MSG_{{name}}{
  {{fields}}
}__attribute__((packed))  MSG_{{name}};

]],
  structfield = "\n  %s %s;",
  struct_comment = "// %s",

  msg_metatable = [[
local {{name}}_mt = {
  __index = {
{{fields:    %s,\n}}  }
}
ffi.metatype("MSG_{{name}}", {{name}}_mt)

]],

  boundscheck_func = [[
check = function(msg, limit)
      local offset = {{msgsize}}
{{checks :%s}}    end]],

  boundscheck_line = [[
      offset = offset + ({{field}} * {{element_size}})
      assert(offset <= limit, "Bad field length for {{name}}")

]]
}

function generator:fmt_fieldget(def, f)
  if self:needs_accessor(def, f) then
    return self:fmt_accessor_get(def, f, "msg")
  else
    return "msg."..f.name
  end
end

function generator:needs_accessor(struct, f)
  return f.vlen or f.type == "bitfield" or f.bitstorage ~= nil
end

function generator:fmt_accessor_def(struct, f, voffset) 
  local body

  if f.vlen then
    local first_cast
    local second_cast

    if f.type == "string" then
      first_cast = "const char*"
      second_cast = "const char*"
    else
      first_cast = "char*"
      second_cast = self.types[f.type].c
    end
    
    if f.vindex == 1 then
      body = format([[ffi_cast("%s", msg+1)]], second_cast)
    else
      body = format([[ffi_cast("%s", msg+1) + (%s)]], first_cast, voffset)
    end
    
    local buflen
    if struct.use_msgsize then
      buflen = "msg.msgsize - " .. struct.size
    elseif f.buflen then
      local buflen_field = struct.fieldlookup[f.buflen]
      assert(buflen_field)
      buflen = self:fmt_fieldget(struct, buflen_field)
    end

    if f.type == "string" then
      assert(buflen)
      body = format("ffi.string(%s, %s)", body, buflen)
    elseif f.type == "stringlist" then
      assert(buflen)
      body = format("parse_strlist(%s, %s)", body, buflen)
    elseif f.vindex ~= 1 then -- We don't need a second cast if this is the first vlen field
      body = format([[ffi_cast("%s", %s)]], second_cast, body)
    end
  elseif f.type == "bitfield" or f.bitstorage then
    body = format("band(rshift(%s, %d), 0x%x)", "msg." .. f.bitstorage, f.bitofs, bit.lshift(1, f.bitsize)-1)
    if f.bool then
      body = body .. " ~= 0"
    end
  else
    assert(body, "unhandled field accessor type")
  end
  
  -- Prevent a tail call be generated by wrapping the body in parentheses
  return format("get_%s = function(msg) return (%s) end", f.name, body)
end

function generator:fmt_accessor_get(struct, f, msgvar)
  return format("%s:get_%s()", msgvar, f.name)
end

function generator:fmt_namelookup(enum, idvar)
  return format("%s_names[%s]", enum, idvar)
end

function generator:writefile(options)
  self:write([=[
local ffi = require("ffi")
local ffi_cast = ffi.cast
local ffi_string = ffi.string
local band = bit.band
local rshift = bit.rshift
local lib = {}

local function make_enum(names)
  local t = {}
  for i, name in ipairs(names)do
      t[name] = i-1
  end
  t.names = names
  return t
end

local function parse_strlist(strlist, bufsize)
  local buf = ffi.cast("const char *", strlist)
  local prev = 0
  local t = {}
  
  for i =0, bufsize-1 do
    if buf[i] == 0 then
      local length = i - prev
      assert(length > 0)
      t[#t + 1] = ffi_string(buf +  prev, length)
      prev = i+1
    end
  end
  return t
end

]=])
  self:write_enum("MsgType", self.sorted_msgnames)
  self:write_msgsizes(false)
  if GC64 then
    self:write([[
lib.GC64 = true

ffi.cdef("typedef uint64_t GCRef, MRef;")]])
  else
    self:write([[
lib.GC64 = false

ffi.cdef("typedef uint32_t GCRef, MRef;")]])
  end
  self:write([=[

ffi.cdef[[
]=])
  local struct_getters = {}
  for _, def in ipairs(self.msglist) do
    local field_getters = self:write_struct(def.name, def)
    if field_getters then
      struct_getters[def.name] = field_getters
    end
  end
  self:write("]]\n")

  for _, def in ipairs(self.msglist) do
    self:writef("assert(ffi.sizeof('MSG_%s') == %d)\n", def.name, def.size)
     if def.enumlist then
      local names = self.namescans[def.enumlist]
      self:write_enum(names.enumname, names.matches)
    end
  end

  for _, def in ipairs(self.msglist) do
    local funclist = struct_getters[def.name]
    if not funclist then
      funclist = {[[check = function() end]]}
    elseif #def.vlen_fields > 0 and not def.use_msgsize then
      table.insert(funclist, self:build_boundscheck(def))
    else
      table.insert(funclist, [[check = function() end]])
    end   
    self:writetemplate("msg_metatable", {name = def.name, msgdef = def, fields = funclist})
  end

  self:write([[

return lib
]])
end

return generator
